
test_print_any :: (any: Any) -> void {
    switch (any.type.kind) {

        case Type_Info_Kind.Integer:
            ii := cast(*Type_Info_Int, any.type);

            if (ii.sign) {
                switch (any.type.size) {
                    case 8: xx_print(<cast(*s64, any.value));
                    case 4: xx_print(<cast(*s32, any.value));
                    case 2: xx_print(<cast(*s16, any.value));
                    case 1: xx_print(<cast(*s8, any.value));
                    default: xx_println("Unhandled integer size in test_print_any");
                }
            } else {
                switch (any.type.size) {
                    case 8: xx_print(<cast(*u64, any.value));
                    case 4: xx_print(<cast(*u32, any.value));
                    case 2: xx_print(<cast(*u16, any.value));
                    case 1: xx_print(<cast(*u8, any.value));
                    default: xx_println("Unhandled integer size in test_print_any");
                }
            }

        case Type_Info_Kind.Real:
            if any.type.size == 4 {
                xx_print(<cast(*r32, any.value));
            } else if any.type.size == 8 {
                xx_print(<cast(*r64, any.value));
            } else {
                xx_println("Unhandled real size in test_print_any");
            }

        case Type_Info_Kind.Bool:
            xx_print(<cast(*bool, any.value));

        case Type_Info_Kind.Pointer:
            pi := cast(*Type_Info_Pointer, any.type);

            value := cast(**void, any.value);

            xx_print("ptr: ");
            value_any : Any = { pi.pointer_to, cast(*u8, <value) };
            test_print_any(value_any);


        case Type_Info_Kind.Struct:
            si := cast(*Type_Info_Struct, any.type);

            if any.type == #type_info(String) {
                strp := cast(*String, any.value);
                xx_print(<strp);
            } else {
                xx_print("{ ");

                struct_mem : []u8;
                struct_mem.data = any.value;
                struct_mem.length = any.type.size;

                for i := 0; i < si.members.length; i += 1 {
                    if i > 0 xx_print(", ");

                    member := si.members[i];
                    member_any : Any = { member.type, *struct_mem[member.offset] };
                    test_print_any(member_any);
                }

                xx_print(" }");
            }

        case Type_Info_Kind.Enum:
            ei := cast(*Type_Info_Enum, any.type);

            name: String = "Invalid enum value";
            for i := 0; i < ei.members.length; i += 1 {
                if ei.members[i].value == <cast(*s64, any.value) {
                    name = ei.members[i].name;

                    // Hack because we don't have break yet
                    i = ei.members.length;
                }
            }

            xx_print(name, "(");
            int_any : Any = { ei.integer_type, any.value };
            test_print_any(int_any);
            xx_print(")");

        case Type_Info_Kind.Static_Array:
            ai := cast(*Type_Info_Static_Array, any.type);

            arr_mem : []u8;
            arr_mem.data = any.value;
            arr_mem.length = ai.length * ai.element_type.size;

            xx_print("{ ");
            for i := 0; i < ai.length; i += 1 {
                if i > 0 xx_print(", ");

                elem_any : Any = { ai.element_type, *arr_mem[ai.element_type.size * i] };
                test_print_any(elem_any);
            }
            xx_print(" }");

        case Type_Info_Kind.Slice:
            si := cast(*Type_Info_Slice, any.type);

            slice := <cast(*[]s64, any.value);

            arr_mem : []u8;
            arr_mem.data = cast(*u8, slice.data);
            arr_mem.length = slice.length * si.element_type.size;

            xx_print("{ ");
            for i := 0; i < slice.length; i += 1 {
                if i > 0 xx_print(", ");

                elem_any : Any = { si.element_type, *arr_mem[si.element_type.size * i] };
                test_print_any(elem_any);
            }
            xx_print(" }");

        case Type_Info_Kind.Function:
            xx_print("fnptr");

        default: xx_println("!!! Unhandled type in test_print_any !!!");
    }
}
