// signed_integer := #run return_signed_integer(7);
// unsigned_integer := #run return_unsigned_integer(8);
// float := #run return_float(4.2);
// double := #run return_double(4.2);
// bool_true := #run return_bool(true);
// bool_false := #run return_bool(false);

// vector := #run make_vector(2, 3);

// #run main();
// main :: () {

//     print(signed_integer);
//     print(unsigned_integer);
//     print(float);
//     print(double);
//     print(bool_true);
//     print(bool_false);

//     vector : Vec2 = { 2, 3 };
//     print_vector(vector);
//     // print_vector({1, 2}); // Need nested infer nodes for this

//     return 0;
// }

// return_signed_integer :: (x: s64) -> s64 {
//     return x;
// }

// return_unsigned_integer :: (x: u64) -> u64 {
//     return x;
// }

// return_float :: (x: r32) -> r32 {
//     return x;
// }

// return_double :: (x: r64) -> r64 {
//     return x;
// }

// return_bool :: (x: bool) -> bool {
//     return x;
// }

Vec2 :: struct {
    x, y: s64;
}

// AABB :: struct {
//     pos, size: Vec2;
// }

// make_vector :: (x: s64, y: s64) -> Vec2 {
//     result : Vec2;
//     result.x = x;
//     result.y = y;
//     return result;
// }

#run main();
main :: () {
    v : Vec2 = { 2, 3 };
    print_vector(v);
    print_vector({4, 2});

    // r : AABB;
    // r.pos = { 1, 2 };
    // r.size = { 3, 4 };

    // print_aabb(r);
    return 0;
}

print_vector :: (v: Vec2) {
    print("Vec2{ ", v.x, ", ", v.y, " }");
}

// print_aabb :: (_r: AABB) {
//     r := _r;
//     print("AABB{ pos: Vec2{ ", r.pos.x, ", ", r.pos.y, " }, size: Vec2{ ", r.size.x, ", ", r.size.y, "} }");
// }
