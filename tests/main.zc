
#run main();

Vec2 :: struct { x, y: r64; }
AABB :: struct { pos, size: Vec2; }

Node :: struct {
    value: s64;
    next: *Node;
}

main :: () {
    println("Type info test!");

    print_ti(#type_info(void));

    println();

    print_ti(#type_info(s64));
    print_ti(#type_info(u64));
    print_ti(#type_info(s32));
    print_ti(#type_info(u32));
    print_ti(#type_info(s16));
    print_ti(#type_info(u16));
    print_ti(#type_info(s8));
    print_ti(#type_info(u8));

    println();

    print_ti(#type_info(r64));
    print_ti(#type_info(r32));

    println();

    print_ti(#type_info(bool));

    println();
    pointers();

    print_ti(#type_info(String));
    print_ti(#type_info(Vec2));
    print_ti(#type_info(AABB));
    print_ti(#type_info(*Vec2));

    print_ti(#type_info(Node));

    return 0;
}

pointers :: () {
    print_ti(#type_info(*void));
    print_ti(#type_info(*s64));
    print_ti(#type_info(*u64));
    print_ti(#type_info(*s32));
    print_ti(#type_info(*u32));
    print_ti(#type_info(*s16));
    print_ti(#type_info(*u16));
    print_ti(#type_info(*s8));
    print_ti(#type_info(*u8));
    print_ti(#type_info(*r64));
    print_ti(#type_info(*r32));
    print_ti(#type_info(*bool));

    print_ti(#type_info(**void));
    print_ti(#type_info(**s32));
    print_ti(#type_info(***void));
    print_ti(#type_info(***s32));
}

print_ti :: (ti: *Type_Info) -> void {

    switch (ti.kind) {

        case Type_Info_Kind.Void:
            print("void, ", ti.size, " bytes");

        case Type_Info_Kind.Integer:
            ii := cast(*Type_Info_Int, ti);

            print("Integer, ", ti.size, " bytes, ");
            if ii.sign print("signed");
            else print("unsigned");


        case Type_Info_Kind.Real:
            print("Real, ", ti.size, " bytes");

        case Type_Info_Kind.Bool:
            print("bool, ", ti.size, " bytes");

        case Type_Info_Kind.Pointer:
            pi := cast(*Type_Info_Pointer, ti);

            print("Pointer: (to: ");
            print_short_type(pi.pointer_to);
            print("), ", ti.size, " bytes");


        case Type_Info_Kind.Struct:
            si := cast(*Type_Info_Struct, ti);
            print("Struct: ", si.name, ", members: { ");

            for i := 0; i < si.members.length; i += 1 {
                member := si.members[i];
                if i > 0 print(", ");
                if member.name.length != 0 print(member.name, ": ");
                print_short_type(member.type);
            }
            print(" }");

        default: print("!!! Unhandled type in 'print_ti'");
    }

    println();
}

print_short_type :: (ti: *Type_Info) -> void {

    switch (ti.kind) {
        case Type_Info_Kind.Void: print("void");
        case Type_Info_Kind.Real: print("r", ti.size * 8);
        case Type_Info_Kind.Bool: print("bool");

        case Type_Info_Kind.Integer:
            ii := cast(*Type_Info_Int, ti);
            if ii.sign print("s"); else print("u");
            print(ti.size * 8);

        case Type_Info_Kind.Pointer:
            pi := cast(*Type_Info_Pointer, ti);
            print("*");
            print_short_type(pi.pointer_to);

        case Type_Info_Kind.Struct:
            si := cast(*Type_Info_Struct, ti);
            print(si.name);

        default: print("!!! Unhandled type in 'print_short_type'");
    }
}
