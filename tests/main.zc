
Vec2 :: struct {
    x, y: r64;
}

#run main();
main :: () {

    x := 42;
    ax : Any = { #type_info(#type_of(x)), cast(*u8, *x) };
    print_any(ax);
    println();

    x2 : u32 = 41;
    ax2 : Any = { #type_info(#type_of(x2)), cast(*u8, *x2) };
    print_any(ax2);
    println();

    y := 4.2;
    ay : Any = { #type_info(#type_of(y)), cast(*u8, *y) };
    print_any(ay);
    println();

    y2 : r64 = 4.3;
    ay2 : Any = { #type_info(#type_of(y2)), cast(*u8, *y2) };
    print_any(ay2);
    println();

    b := true;
    ab : Any = { #type_info(#type_of(b)), cast(*u8, *b) };
    print_any(ab);
    println();

    b2 := false;
    ab2 : Any = { #type_info(#type_of(b2)), cast(*u8, *b2) };
    print_any(ab2);
    println();

    px := *x;
    apx : Any = { #type_info(#type_of(px)), cast(*u8, *px) };
    print_any(apx);
    println();

    py := *y;
    apy : Any = { #type_info(#type_of(py)), cast(*u8, *py) };
    print_any(apy);
    println();

    ppx := *px;
    appx : Any = { #type_info(#type_of(ppx)), cast(*u8, *ppx) };
    print_any(appx);
    println();

    str := "Hello!";
    astr : Any = { #type_info(#type_of(str)), cast(*u8, *str) };
    print_any(astr);
    println();

    vec : Vec2 = { 1.2, 5.4 };
    avec : Any = { #type_info(#type_of(vec)), cast(*u8, *vec) };
    print_any(avec);
    println();


    return 0;
}

print_any :: (any: Any) -> void {
    switch (any.type.kind) {

        case Type_Info_Kind.Integer:
            ii := cast(*Type_Info_Int, any.type);

            if (ii.sign) {
                switch (any.type.size) {
                    case 8: print(<cast(*s64, any.value));
                    case 4: print(<cast(*s32, any.value));
                    case 2: print(<cast(*s16, any.value));
                    case 1: print(<cast(*s8, any.value));
                    default: println("Unhandled integer size in print_any");
                }
            } else {
                switch (any.type.size) {
                    case 8: print(<cast(*u64, any.value));
                    case 4: print(<cast(*u32, any.value));
                    case 2: print(<cast(*u16, any.value));
                    case 1: print(<cast(*u8, any.value));
                    default: println("Unhandled integer size in print_any");
                }
            }

        case Type_Info_Kind.Real:
            if any.type.size == 4 {
                print(<cast(*r32, any.value));
            } else if any.type.size == 8 {
                print(<cast(*r64, any.value));
            } else {
                println("Unhandled real size in print_any");
            }

        case Type_Info_Kind.Bool:
            print(<cast(*bool, any.value));

        case Type_Info_Kind.Pointer:
            value := cast(**void, any.value);
            print(<value, " :");
            value_any : Any;
            value_any.value = cast(*u8, <value);

            pi := cast(*Type_Info_Pointer, any.type);
            value_any.type = pi.pointer_to;

            print_any(value_any);

        case Type_Info_Kind.Struct:
            si := cast(*Type_Info_Struct, any.type);

            if any.type == #type_info(String) {
                strp := cast(*String, any.value);
                print(<strp);
            } else {
                print("{ ");

                struct_mem : []u8;
                struct_mem.data = any.value;
                struct_mem.length = any.type.size;

                for i := 0; i < si.members.length; i += 1 {
                    if i > 0 print(", ");

                    member := si.members[i];
                    member_any : Any = { member.type, *struct_mem[member.offset] };
                    print_any(member_any);
                }

                print(" }");
            }

        default: println("!!! Unhandled type in print_any !!!");
    }
}

