
binop_fn :: #type (s64, s64) -> s64;

add_s64 :: (a: s64, b: s64) -> s64 {
    return a + b;
}

sub_s64 :: (a: s64, b: s64) -> s64 {
    return a - b;
}

mul_s64 :: (a: s64, b: s64) -> s64 {
    return a * b;
}

S :: struct {
    fn : binop_fn;
}

return_binop_fn :: () {
    return add_s64;
}

both :: ( f1: binop_fn, f2: binop_fn,
          a: s64, b: s64) {

    println(f1(a, b));
    println(f2(a, b));

}

sub :: sub_s64;

#run main();
main :: () {

    first : binop_fn;

    {
        add := add_s64;
        println(add(1, 2));
        lc := add;
        println(lc(1, 2));
    }

    {
        add : (s64, s64) -> s64 = add_s64;
        println(add(2, 3));
        first = add;
    }

    println(first(3, 4));

    {
        s : S;
        s.fn = add_s64;
        println(s.fn(4, 5));
        lc := s.fn;
        println(lc(4, 5));
    }

    {
        s : S = { add_s64 };
        println(s.fn(4, 5));
    }

    println(return_binop_fn()(5, 6));

    funcs : [2]binop_fn = { add_s64, sub_s64 };
    println(funcs[0](6, 7));
    println(funcs[1](6, 7));

    func_slice : [](s64, s64) -> s64 = funcs;
    println(func_slice[0](7, 8));
    func_slice[1] = mul_s64;
    println(func_slice[1](7, 8));

    println(funcs[0](6, 7));
    println(funcs[1](6, 7));

    both(mul_s64, sub_s64, 42, 24);

    add :: add_s64;

    println(add(11, 22));
    println(sub(11, 22));


    return 0;
}
